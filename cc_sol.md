CC를 낮추는 방법 (리팩토링)
함수 분리 (Extract Method): 긴 함수를 기능별로 작은 함수로 쪼갭니다. (가장 효과적)
조건문 단순화: 복잡한 if-else 중첩을 Guard Clause(조기 리턴) 패턴으로 변경합니다.
다형성 활용: 거대한 switch 문을 객체지향의 다형성(Strategy Pattern 등)으로 대체합니다.


C언어에서도 **다형성(Polymorphism)을 활용할 수 있습니다.**

물론 C++, Java처럼 `class`, `virtual`, `interface` 같은 키워드가 언어 차원에서 제공되지는 않지만, **함수 포인터(Function Pointer)**와 **구조체(Struct)**를 활용하면 다형성을 흉내 낼 수 있으며, 이를 통해 CC(순환 복잡도)를 획기적으로 낮출 수 있습니다.

C언어에서 `switch-case` 문(높은 CC)을 **함수 포인터 테이블**로 변경하여 복잡도를 낮추는 방법을 예시로 보여드리겠습니다.

---

### 상황: 명령어를 처리하는 코드

가정: 패킷 타입에 따라 다른 동작을 하는 프로그램을 만든다고 합시다.

#### 1. 변경 전: `switch-case` 사용 (CC가 높음)
명령어가 늘어날 때마다 `case`가 추가되어 CC가 계속 증가합니다.

```c
// CC = 1(기본) + 3(case) = 4
// 만약 명령어가 100개라면 CC는 101이 됩니다.
void process_packet(int packet_type) {
    switch (packet_type) {
        case CMD_LOGIN:
            handle_login();
            break;
        case CMD_LOGOUT:
            handle_logout();
            break;
        case CMD_MESSAGE:
            handle_message();
            break;
        default:
            handle_error();
            break;
    }
}
```

#### 2. 변경 후: 함수 포인터 배열 사용 (CC가 낮음)
이 방식은 **테이블 구동 방식(Table-Driven Method)**이라고도 부르며, C언어에서 다형성을 구현하는 가장 대표적인 패턴입니다.

```c
// 1. 공통된 함수 형태(인터페이스) 정의
typedef void (*HandlerFunc)(void);

// 2. 각 기능을 수행하는 함수들 (구체적인 구현)
void handle_login()   { /* ... */ }
void handle_logout()  { /* ... */ }
void handle_message() { /* ... */ }
void handle_error()   { /* ... */ }

// 3. 함수 포인터 배열(테이블) 생성 - 이것이 '매핑' 역할
HandlerFunc handlers[] = {
    handle_login,   // 0번 인덱스
    handle_logout,  // 1번 인덱스
    handle_message  // 2번 인덱스
};

// 4. 실행 코드
// CC = 1 (분기문이 아예 사라짐)
void process_packet(int packet_type) {
    // 유효성 검사 (필요 시 if문 한두 개 정도 추가됨)
    if (packet_type < 0 || packet_type >= MAX_CMD_COUNT) {
        handle_error();
        return;
    }

    // 배열 인덱스로 바로 접근하여 실행 (다형성과 유사한 효과)
    handlers[packet_type](); 
}
```

### 이 방식의 효과

1.  **CC 감소:** 명령어가 100개로 늘어나도 `process_packet` 함수의 **CC는 여전히 1~2**로 유지됩니다. 제어 흐름(분기)이 데이터(배열)로 대체되었기 때문입니다.
2.  **확장성:** 새로운 명령어가 추가되면 `handlers` 배열에 함수 이름만 등록하면 됩니다. 실행 로직을 건드릴 필요가 없습니다(OCP 원칙 준수).

---

### 심화: 구조체를 이용한 객체지향 흉내 (OOP Simulation)

C언어에서 리눅스 커널이나 드라이버 코드를 보면 구조체 안에 함수 포인터를 넣어 **마치 객체의 메서드처럼** 사용하는 것을 볼 수 있습니다.

```c
struct FileOperations {
    void (*open)(char* path);
    void (*read)(void* buffer);
    void (*close)(void);
};

// 사용 시
struct FileOperations myDriver = { my_open, my_read, my_close };

// 다형성처럼 동작 (어떤 드라이버가 들어오든 코드는 똑같음)
void perform_task(struct FileOperations* driver) {
    driver->open("/path/file");  // 구현체가 무엇이든 상관없이 호출
    driver->read(buf);
}
```

### 요약
C언어에서는 **함수 포인터**를 활용하여 다형성을 구현할 수 있으며, 이를 통해 거대한 `if-else`나 `switch` 문을 제거하여 **CC 매트릭 점수를 효과적으로 낮출 수 있습니다.**

함수 포인터는 C언어에서 다형성을 구현하고 CC(순환 복잡도)를 낮추는 강력한 도구이지만, **"모든 기술에는 트레이드오프(Trade-off)가 있다"**는 원칙처럼 명확한 단점들도 존재합니다.

주요 단점은 크게 **가독성/디버깅**, **성능**, **안전성** 세 가지 측면으로 나눌 수 있습니다.

---

### 1. 가독성 및 디버깅의 어려움 (가장 큰 단점)
`if-else`나 `switch`는 눈에 보이는 대로 실행되지만, 함수 포인터는 **실행 시점(Runtime)**이 되어야 어떤 함수가 호출될지 결정됩니다.

*   **흐름 추적의 어려움:** 코드를 읽을 때 `func_ptr()`라고 적혀 있으면, 정적 분석(코드만 보고 파악)만으로는 실제로 `login()`이 실행될지 `logout()`이 실행될지 알 수 없습니다. 테이블 초기화 코드를 찾아가서 확인해야 하는 번거로움이 있습니다.
*   **IDE 지원 제한:** 일반 함수는 `Ctrl + 클릭`으로 정의로 바로 이동할 수 있지만, 함수 포인터는 해당 포인터 변수의 선언부로만 이동될 뿐, 실제 연결된 함수로 이동하지 못하는 경우가 많습니다.

### 2. 컴파일러 최적화 방해 (성능 이슈)
현대 컴파일러는 매우 똑똑하지만, 함수 포인터를 사용하면 최적화에 제약이 걸립니다.

*   **인라인(Inline) 불가:** 컴파일러는 작은 함수를 호출부 코드에 그대로 복사해 넣는 '인라인 최적화'를 수행하여 속도를 높입니다. 하지만 함수 포인터는 **컴파일 타임에 어떤 함수가 불릴지 모르므로** 인라인 처리를 할 수 없습니다.
*   **분기 예측(Branch Prediction) 실패:** CPU는 속도를 위해 다음에 실행할 코드를 미리 예측하는데, 함수 포인터를 통한 호출(Indirect Call)은 목적지가 계속 바뀌므로 예측이 어렵습니다. 예측 실패 시 CPU 파이프라인이 비워지며 성능 저하가 발생할 수 있습니다.
    *   *참고: 일반적인 비즈니스 로직에서는 미미한 차이지만, 초고성능이 요구되는 임베디드나 게임 엔진 루프에서는 중요할 수 있습니다.*

### 3. 안전성 문제 (Human Error)
C언어는 타입 검사가 느슨하기 때문에 개발자의 실수가 치명적인 오류로 이어질 수 있습니다.

*   **잘못된 형변환 (Signature Mismatch):**
    인자가 `int` 하나인 함수를 넣어야 할 자리에, 인자가 `void`인 함수를 강제로 캐스팅해서 넣으면 컴파일 에러는 안 나지만, 실행 시 **스택 메모리가 깨지거나 엉뚱한 동작**을 할 수 있습니다.
*   **NULL 포인터 역참조:**
    `switch-case`의 `default` 처럼 예외 처리를 꼼꼼히 하지 않고, 초기화되지 않은 함수 포인터를 호출하면 바로 **Segfault(프로그램 충돌/종료)**가 발생합니다.

### 4. 보안 취약점
해커들이 공격할 때 함수 포인터는 좋은 먹잇감이 됩니다. 버퍼 오버플로우 등의 취약점을 이용해 함수 포인터의 주소를 악성 코드가 있는 주소로 덮어씌우면, 프로그램이 해커가 의도한 코드를 실행하게 만들 수 있습니다.

---

### 요약 및 결론

| 구분 | Switch-Case (분기문) | 함수 포인터 (테이블 방식) |
| :--- | :--- | :--- |
| **CC (복잡도)** | 높음 (나쁨) | **낮음 (좋음)** |
| **가독성** | 직관적 | 흐름 파악 어려움 |
| **성능** | 컴파일러 최적화 용이 | **인라인 불가, 분기 예측 불리** |
| **안전성** | 비교적 안전 | NULL 체크 필수, 타입 주의 |

**[언제 써야 할까요?]**
*   **단순한 분기(3~5개 미만):** 그냥 `if-else`나 `switch`를 쓰는 것이 가독성과 성능 면에서 훨씬 좋습니다. 굳이 함수 포인터를 써서 코드를 어렵게 만들 필요가 없습니다.
*   **복잡한 분기(10개 이상) 또는 확장성 필요:** 명령어 처리, 상태 머신(FSM), 드라이버 인터페이스처럼 **확장성**이 중요하고 **CC를 낮춰야 할 때** 함수 포인터를 사용하는 것이 이득입니다.

