효과적인 `#include` 전략은 단순히 오류를 막는 것을 넘어, **컴파일 속도 향상, 유지보수 용이성, 그리고 의존성 지옥(Dependency Hell) 방지**를 목표로 합니다.

C/C++ 프로젝트에서 권장되는 효과적인 include 관리 원칙 5가지를 정리해 드립니다.

---

### 1. "헤더에는 최소한만, 소스(.c)에는 최대한 많이"
가장 중요한 원칙입니다. 헤더 파일은 다른 여러 파일에 복사되므로, 헤더가 무거워지면 프로젝트 전체의 컴파일 속도가 느려집니다.

*   **헤더 파일(.h):** 가능하면 `#include` 대신 **전방 선언(Forward Declaration)**을 사용하세요. 구조체의 포인터만 사용한다면 전방 선언으로 충분합니다.
*   **소스 파일(.c):** 구조체의 내부 멤버에 접근해야 하는 실제 로직이 작성되므로, 이때 필요한 헤더들을 모두 `#include` 합니다.

### 2. 헤더 가드(Header Guard)의 표준화
중복 포함을 방지하기 위해 모든 헤더에 반드시 적용해야 합니다.

*   **`#pragma once`**: 현대 컴파일러에서 대부분 지원하며, 쓰기 간편하고 파일 이름 변경에 영향을 받지 않아 권장됩니다.
*   **`#ifndef` 방식**: 표준 C 방식이며 이식성이 가장 높습니다. 프로젝트만의 고유한 접두어를 붙여 충돌을 방지하세요. (`PROJECT_MODULE_FILENAME_H`)

### 3. 포함 순서의 최적화 (Self-contained Check)
구글 등 글로벌 기업에서 사용하는 표준적인 include 순서입니다. 이 순서는 **"내 헤더 파일이 독립적으로 컴파일 가능한가?"**를 자동으로 검증해 줍니다.

**[권장 순서: 소스 파일(main.c, module.c 등) 기준]**
1.  **해당 .c와 짝을 이루는 .h 파일** (최상단에 배치하여 해당 헤더가 필요한 요소를 스스로 모두 포함하고 있는지 검증)
2.  **프로젝트 내의 다른 헤더**
3.  **외부 라이브러리 헤더** (OpenSSL, Zlib 등)
4.  **표준 C 라이브러리 헤더** (`<stdio.h>`, `<stdlib.h>` 등)

```c
// 예: logic.c
#include "logic.h"      // 1순위: 자기 자신의 헤더 (가장 먼저!)

#include "util.h"       // 2순위: 프로젝트 내 다른 헤더
#include <openssl/aes.h>// 3순위: 외부 라이브러리
#include <stdio.h>      // 4순위: 시스템 표준 라이브러리
```

### 4. "Include What You Use" (IWYU) 원칙
내가 직접 사용하는 함수나 타입이 정의된 헤더는 **직접 include** 하세요.

*   **나쁜 예:** `A.h`가 `B.h`를 포함하고 있을 때, `main.c`에서 `B.h`에 있는 함수를 쓰면서 `A.h`만 포함하는 경우.
*   **문제점:** 나중에 `A.h`에서 `B.h`가 필요 없어져서 제거하면, 상관없어 보이던 `main.c`까지 컴파일 에러가 발생합니다. 의존성 추적이 매우 어려워집니다.

### 5. 거대 헤더(Monolithic Header) 피하기
`common.h`, `all_types.h`와 같이 프로젝트의 모든 것을 담은 헤더 파일을 만드는 것은 **매우 위험**합니다.

*   **이유:** 그중 단 한 줄만 수정해도 프로젝트 전체를 다시 컴파일(Rebuild All)해야 합니다.
*   **해결:** 기능별로 헤더를 쪼개고, 꼭 필요한 파일만 포함하도록 관리하세요.

---

### 실전 체크리스트
1.  **포인터로만 사용되는 구조체인가?** → 헤더에서 `#include` 지우고 `struct Name;`으로 **전방 선언** 하세요.
2.  **이 헤더가 다른 곳에서도 자주 쓰이나?** → 헤더 내부에서 불필요한 다른 헤더를 include 하고 있지 않은지 확인하세요.
3.  **순환 참조가 발생했나?** → 두 헤더 중 하나에서 상대방을 `#include` 하는 대신 전방 선언을 사용하고, 포함 관계를 소스 파일(.c)로 옮기세요.
4.  **컴파일 속도가 너무 느린가?** → `IWYU` 도구나 시각화 도구를 사용해 얽혀있는 실타래를 푸세요.

이 원칙들만 지켜도 C 언어 프로젝트에서 발생하는 의존성 문제의 90% 이상을 예방할 수 있습니다.


IWYU가 너무 무겁거나 설정이 까다롭다면, 다음 순서로 접근해 보세요.
1단계: cpp-dependencies 사용
프로젝트 전체의 디렉토리 간 순환 참조만 먼저 찾아냅니다. (가장 큰 설계 결함 제거)
2단계: gcc -H 혹은 Clang의 -ftime-trace
빌드 시간이 가장 오래 걸리는 파일(Bottleneck)을 찾습니다.
3단계: 해당 파일만 IWYU 적용
병목이 되는 지점만 핀포인트로 전방 선언을 적용해 의존성을 끊어냅니다.